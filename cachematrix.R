# The following two functions, when used together, provide a method for
# solving the inverse of a square invertible matrix and caching that inverse.

# The makeCacheMatrix function takes as an optional argument a square invertible
# matrix and returns a special 'matrix' that is actually a list of functions for
# performing actions on the provided matrix.  The functions are...
#
# 1. setMatrix - used to pass in the matrix (if it wasn't provided as
#                an argument in the initial call of makeCacheMatrix or if it
#                needs to be reset)
#
# 2. getMatrix - simply returns the matrix
#
# 3. setInverse - used to store the inverse matrix when it is calculated (but
#                 setInverse doesn't actually calculate the inverse, see the
#                 cacheSolve function, below, for that)
#
# 4. getInverse - returns the inverse matrix (or returns NULL if no inverse
#                 matrix has been stored)
#
# For example, given...
# > a <- matrix(1:4,2,2)
# > m <- makeCacheMatrix()
# the matrix 'a' can be passed in with
# > m$setMatrix(a)
# and the matrix can be retrieved with
# > m$getMatrix()
# etc.

makeCacheMatrix <- function(x = matrix()) {
        inv <- NULL
        setMatrix <- function(y) { x <<- y; inv <<- NULL }
        getMatrix <- function() x
        setInverse <- function(z) inv <<- z
        getInverse <- function() inv
        list(setMatrix = setMatrix, getMatrix = getMatrix,
             setInverse = setInverse, getInverse = getInverse)
}


# The cacheSolve function takes as a required argument the list of functions
# generated by makeCacheMatrix and does one of two things...
#
# If a inverse matrix has already been stored, cacheSolve presents a message
# "getting chached inverse" and then returns that inverse matrix.
#
# Otherwise cacheSolve calculates the inverse, stores it using the setInverse
# function, and returns the inverse.
#
# Continuing the above example...
# assuming the setInverse function has not yet run for the 'm' list of 
# makeCacheMatrix generated functions, the first call of cacheSolve calulates
# the inverse, stores it using setInverse and returns the inverse:
# >  cacheSolve(m)
# [,1] [,2]
# [1,]   -2  1.5
# [2,]    1 -0.5
# Subsequent calls of cacheSolve just return the inverse with a message:
# > cacheSolve(m)
# getting cached inverse
# [,1] [,2]
# [1,]   -2  1.5
# [2,]    1 -0.5
# until the matrix in m is reset using m$setMatrix or using a new
# call of makeCacheMatrix

cacheSolve <- function(x, ...) {
        inv <- x$getInverse()
        if(!is.null(inv)) {
                message("getting cached inverse")
                return(inv)
        }
        data <- x$getMatrix()
        inv <- solve(data, ...)
        x$setInverse(inv)
        inv
}
